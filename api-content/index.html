{"posts":[{"title":"在Mac上shift切换输入法","content":" 安装Karabiner-Elements，下载地址:https://pqrs.org/osx/karabiner/。 或者：链接:https://pan.baidu.com/s/13sFMD0kcHUMX9nnciOBplA 密码:18sc 添加规则，这里使用已经配置好的规则脚本下载地址。 链接:https://pan.baidu.com/s/1GrucN71iQ3vvriL1PTvCZQ 密码:4a0i 将下载的配置文件放到~/.config/karabiner/assets/complex_modifications目录下。mv ~/Downloads/left_shift_2_F17.json ~/.config/karabiner/assets/complex_modifications 打开Karabiner-Elements，点击Complex Modifications -&gt; Add rule，点击规则 Change left_shift to F17 when used alone右侧的Enable按钮。将看到配置完成的界面。 打开 系统偏好设置-&gt;键盘-&gt;快捷键-&gt;输入法，选择上一个输入法，按下shift键。 [注意] 最好只选择两个简体拼音和abc。 图中红色标注的不要选！ ","link":"https://qyylovexqx.github.io/post/zai-mac-shang-shift-qie-huan-shu-ru-fa/"},{"title":"Java集合删除元素","content":"精简概括： 1、普通for循环+集合的remove方法：会出现被删除元素的后一个元素被跳过的现象 2、foreach遍历+集合的remove方法：删除时会出现ConcurrentModificationException异常 3、迭代器+集合的remove方法：删除时会出现ConcurrentModificationException异常 4、迭代器+迭代器的remove方法：符合预期，没有任何问题 ConcurrentModificationException异常出现的原因： ArrayList的父类AbstarctList中有一个域modCount，每次对集合进行修改（增添、删除元素）时modCount都会+1。迭代ArrayList的Iterator中有一个变量expectedModCount，该变量会初始化和modCount相等，但当对集合进行插入，删除操作，modCount会改变，就会造成expectedModCount!=modCount，此时就会抛出java.util.ConcurrentModificationException异常。 【注】详细代码分析 /** By Qyy */ public class TestListIterator { public static void main(String[] args) { java.util.ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Iterator iterator = list.iterator(); /** * 第一种：使用普通for循环遍历+集合的remove方法有什么问题？ * * 输出结果： * [1, 2, 3, 4, 5] * 1 * [1, 2, 3, 4, 5] * 2 * [1, 2, 3, 4, 5] * 3 * [1, 2, 4, 5] * 5 * * 分析：i==3，且未删除list中第三个元素时，list集合：{1,2,3,4,5} * 当执行list.remove(list.get(i))后，list集合：{1,2,4,5} * 随后i++，list.get(4),循环结束 * * 答案：使用集合删除元素时，如果删除成功，删除位置后面的元素会向前移动一个单位， * 所以会造成被删除元素的后一个元素被&quot;跳过&quot;，没有遍历到的现象 * */ for(int i=0;i&lt;list.size();i++){ System.out.println(list); System.out.println(list.get(i)); if(list.get(i)==3){ list.remove(list.get(i)); } } /** * 是否可能出现数据越界异常？ * * 结果： *[1, 2, 3, 4, 5] * 1 * [1, 2, 3, 4, 5] * 2 * [1, 2, 3, 4, 5] * 3 * [1, 2, 3, 4, 5] * 4 * * 分析：当删除第四个元素后，i++以后i=5,此时，list.size==4,不满足循环条件，所以不会出现数组越界 * 因为for循环的执行顺序为： * for(①;②;④){ * ③ * } * * 答案：不会 */ for(int i=0;i&lt;list.size();i++){ System.out.println(list); System.out.println(list.get(i)); if(list.get(i)==4){ list.remove(list.get(i)); } } /** * 第二种：使用foreach遍历+集合的删除方法有什么问题？ * * 结果： * [1, 2, 3, 4, 5] * 1 * [1, 2, 3, 4, 5] * 2 * [1, 2, 3, 4, 5] * 3 * Exception in thread &quot;main&quot; java.util.ConcurrentModificationException * at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1009) * at java.base/java.util.ArrayList$Itr.next(ArrayList.java:963) * at Note.TestListIterator.main(TestListIterator.java:67) * at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) * at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) * at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) * at java.base/java.lang.reflect.Method.invoke(Method.java:567) * at com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131) * * 分析：foreach 底层使用的是迭代器 * * 答案：会出现ConcurrentModificationException,具体原因见第三种分析 * */ for (Integer i: list) { System.out.println(list); System.out.println(i); if (i == 3) { list.remove(i); } } /** * 第三种：迭代器+集合的删除方法有什么问题？ * * 结果： * [1, 2, 3, 4, 5] * 1 * [1, 2, 3, 4, 5] * 2 * [1, 2, 3, 4, 5] * 3 * Exception in thread &quot;main&quot; java.util.ConcurrentModificationException * at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1009) * at java.base/java.util.ArrayList$Itr.next(ArrayList.java:963) * at Note.TestListIterator.main(TestListIterator.java:100) * at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) * at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) * at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) * at java.base/java.lang.reflect.Method.invoke(Method.java:567) * at com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131) * *分析：该现象和使用foreach+集合remove的结果完全相同。 * * 答案： * ArrayList的父类AbstarctList中有一个字段modCount，每次对集合进行修改（增添、删除元素）时modCount都会+1。 * 迭代ArrayList的Iterator中有一个字段expectedModCount，该变量会初始化和modCount相等， * 但当对集合进行插入，删除操作，modCount会改变，就会造成expectedModCount!=modCount， * 此时就会抛出java.util.ConcurrentModificationException异常 */ while (iterator.hasNext()){ Integer i= iterator.next(); System.out.println(list); System.out.println(i); if(i==3){ list.remove(i); } } /** * 第四种：使用迭代器+迭代器删除 * * 结果： * [1, 2, 3, 4, 5] * 1 * [1, 2, 3, 4, 5] * 2 * [1, 2, 3, 4, 5] * 3 * [1, 2, 4, 5] * 4 * [1, 2, 4, 5] * 5 * * 没有任何问题！不会出现问题 */ while (iterator.hasNext()){ Integer i=iterator.next(); System.out.println(list); System.out.println(i); if(i==3){ iterator.remove(); } } } } ","link":"https://qyylovexqx.github.io/post/java-ji-he-shan-chu-yuan-su/"},{"title":"JVM读书笔记<1>","content":"运行时数据区： 程序计数器：记录当前线程所执行的字节码指令的地址。 虚拟机栈：包含了多个栈帧(局部变量表、操作数栈、动态链接、方法出口),一个方法=一个栈帧。 本地方法栈。 堆：新生代(Eden、From survivor，To Survivor)、老年代。 方法区：存储类信息、运行时常量池(字面量，符号引号与直接引用)、静态变量、JIT编译后的缓存代码数据。 特点： 线程共享：堆、方法区 线程独享：程序计数器、虚拟机栈、本地方法栈。 变化 ","link":"https://qyylovexqx.github.io/post/jvm-du-shu-bi-ji-less1greater/"},{"title":"JVM读书笔记<8、Class文件的结构以及类加载的过程>","content":"Class文件结构 1、魔数和版本号 2、常量池：字面量和符号引用。【注】类加载进内存后，符号引号还会被翻译为直接地址引用 符号引用包括：①类和接口的全限定名、②字段的名称和描述符。③方法的名称和描述符。 3、访问标志 4、字段表：用于描述接口或类中声明的变量。包括静态/成员变量，不包括方法内的局部变量 5、方法表：用于描述方法 6、属性表：字段表、方法表中都有自己的属性表。比如方法表中有Code、LocalVariableTable属性 类加载过程 1、加载： * ①通过类的全限定名获取该类的二进制字节流。 * ②将字节流所代表的的静态存储结构转化为方法区的运行时数据结构 * ③在方法区中生成代表该类的Class对象，作为方法区该类各种数据的访问入口。 2、连接： * 2.1验证： * ①文件格式验证(验证字节流)：验证字节流是否符合Class文件格式的规范，如魔 数、版本号验证。 * ②元数据验证(验证方法区中的存储结构)：对类的元数据信息进 行语义校验。 * ③字节码验证(验证方法区中的存储结构)：程序语义校验。④符号引用验证(验证方法区中的存储 结构)：对类自身以外的信息进行匹配性校验。 * 2.2准备：为静态变量分配内存，并设置静态变量默认值。常量直接赋初始值。 * 2.3解析：将常量池中的符号引用(类、接口、字段、方法等符号引用)转换为直接引用 3、初始化：执行类构造器()方法，包含了类变量的赋值语句和静态代码块的语句 ","link":"https://qyylovexqx.github.io/post/jvm-du-shu-bi-ji-less8class-wen-jian-de-jie-gou-yi-ji-lei-jia-zai-de-guo-cheng-greater/"},{"title":"Redis读书笔记<5、Redis中的主从复制和哨兵模式>","content":"Redis的复制（Master/Slave） 主从复制：主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 作用 读写分离 容灾恢复 配置主从redis的过程 配从(库)不配主(库) 从库配置： Info replication 查看当前redis数据库的信息 slaveof 主库IP 主库端口 修改配置文件细节操作 拷贝多个redis.conf文件 开启daemonize yes Pid 文件名字 指定端口 Log文件名字 Dump.rdb名字 常用配置策略 一主二仆 常见问题 从机不允许写，只允许读 主机死了之后，从机的状态会变为down，等待主机重新开启。主机重新开启后，从机状态会转为up 从机死了之后，重新连接以后，需要重新配置主从关系 薪火相传 上一个Slave可以是下一个slave的Master，Slave同样可以接受其他slaves的连接和同步请求，那么该slave作为链路中下一个的master(只是相对于，整个链路只会存在一个身份为master的主机)，可以有效减轻master的写压力。 中途变更转向：会清除之前的数据，重新建立拷贝最新的 Slaveof 新主库ip 新主库端口 反客为主 Slaveof no one，使当前数据库停止与其他数据库的同步，转为主数据库 复制原理 slave启动成功连接到master后会发送一个同步命令 master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，以完成一次完全同步。 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：master继续将新的所有收集到的修改命令依次传送给slave，完成同步 【注】只要是重新连接master，全量复制将被自动执行 哨兵模式（sentinel） 自动版本的反客为主，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 使用步骤： 自定义的/myredis目录下新建sentinel.com文件 配置哨兵，填写内容：sentinel monitor 被监控数据库名字(自己起名) 127.0.0.1 6379 1 ，其中最后一个数字，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机 启动哨兵：redis-sentinel /dir/sentinel.conf。按实际情况配置，可能目录不同 【注】当原有的master宕机后，会进行重新投票选择新的master，当老版本的master重新启动后，会变成从机。 一组sentinel能同时监控多个master 复制的缺点：由于所有的写操作都是先在master上操作，然后同步更新到slave上，所以从master同步到slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使这个问题更加严重 ","link":"https://qyylovexqx.github.io/post/redis-du-shu-bi-ji-less5redis-zhong-de-zhu-cong-fu-zhi-he-shao-bing-mo-shi-greater/"},{"title":"Redis读书笔记<4、Redis中的事务>","content":"Redis的事务 常用命令 DISCARD:取消事务，放弃执行事务块内的所有命令 EXEC：执行所有事务块内的命令 MULTI：标记一个事务块的开始 UNWATCH：取消WATCH命令对所有key的监视 WATCH key [key.....]：监视一个（或多个）key，如果在事务执行之前，这个（或这些）key被其他命令所改动，那么事务将被打断。 正常执行：MULTI 操作1 操作2 操作3 EXEC 放弃事务：MULTI 操作1 操作2 操作3 DISCARD 事务异常： 命令入队前出错也事务中的其他操作全部都不能执行：比如执行非法命令，命令没有入队。 命令入队后出错事务中的其他操作可以正常执行：比如对非数字字符串进行加减操作，开启事务后，不会直接报错，而是会加入队列 Watch监控： Watch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，则整个事务都不会被执行 通过Watch命令在事务执行之前监控了多个keys，倘若在WATCH之后又任何Key的值发生了变化，则EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败 事务的三个阶段 开启：以MULTI开始一个事务 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里 执行：由EXEC命令触发事务 事务的三个特性 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在&quot;事务内的查询要看到事务里的更新，在事务外查询不能看到”这个问题 不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。见事务异常第二条。 ","link":"https://qyylovexqx.github.io/post/redis-du-shu-bi-ji-less4redis-zhong-de-shi-wu-greater/"},{"title":"Redis读书笔记<3、Redis两种持久化方式>","content":"Redis的持久化 RDB（Redis DataBase） 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是snapshot快照，它恢复时将快照文件直接读到内存中。Redis会单独fork/创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化进程结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常铭感，那RDB方式要比AOF方式更加的高效。RBD的缺点是最后一次持久化后的数据可能丢失。 Fork函数：复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 RDB保存的是dump.rdb文件 配置位置：redis.conf文件中SNAPSHOTTING快照 Save: Stop-writes-on-bgsave-error: 默认为yes，如果配置为no，表示不在乎数据不一致。 rdbcompression：默认为yes，对于存储到磁盘中的快照，可以设置是否进行压缩存储，如果为Yes,redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭。 rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。 dbfilename：rdb文件名称 dir： 触发RDB快照的时机： RBD快照默认触发时机 1分钟内修改了1万次 = save 60 10000 5分钟内修改了10次 =save 300 10 15分钟内修改了1次=save 900 1 可以在redis.conf配置文件中修改save参数 Save 若没有设置任何Save指令或者save &quot;&quot; ，则表示禁用RDB持久化策略 save/bgsave命令(在控制台直接使用) save：只管保存，其他不管，全部阻塞 Bgsave：redis会在后台异步进行快照操作，快照同时还可以相应客户端请求，可以通过lastsave命令获取最后一次成功执行快照的时间 flushall命令，也会触发产生dump.rgb文件，但是个空文件，无意义 如何恢复 将备份文件(dump.rdb)移动到redis安装目录并启动服务即可 CONFIG get dir获取目录 优势 适合大规模的数据恢复 对数据完整性和一致性要求不高 劣势 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改 fork的时候： 内存的数据被克隆了一份，消耗了2倍的内存。 当数据集比较大时，fork过程比较耗时，导致redis响应慢 关闭方式：在redis.conf文件中，若没有设置任何Save指令或者save &quot;&quot; ，则表示禁用RDB持久化策略 AOF（Append Only File） 日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，在aof文件体积变得过大时，自动的在后台对AOF进行重写。redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF保存的是appendonly.aof文件，一个只进行追加的日志文件，有序的保存了对数据库执行的所有写入操作，这些写入操作以redis协议的格式保存，因此AOF文件的内容可读性较高,其存储路径与RDB一样 配置位置：redis.conf文件中Append Only Mode Appendonly no 默认是no，yes就是打开aof持久化 appendfilename 文件名：aof文件 appendfsync Always：同步持久化，每次发生数据变更会被立即记录到磁盘 性能较差，但数据完整性比较好 Everysec：出厂默认推荐，异步操作，每秒记录，如果一秒内宕机，有数据丢失 No No-appendfsync-on-rewrite:重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性 Auto-aof-rewrite-min-size：设置重写的基准值 Auto-aof-rewrite-percentage：设置重写的基准值 AOF启动/修复/恢复 启动：将redis.conf文件中Appendonly no 改为yes 恢复：重启redis，然后加载appendonly.aof 修复： redis-check-aof --fix aof文件 进行修复 Rewrite AOF采用文件追加方式，文件会越来越大为避免出现这种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof 原理：AOF文件持续增大而过大时，会fork出一条新进程来将文件重写（也就是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set语句，重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。 触发机制：redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发 优势： 每秒同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性好 修改时同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失 不同步：appendfsync no 从不同步 劣势： 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同 AOF和RDB 二者可以共存使用，但是优先使用AOF来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB数据不实时，同时使用两者时服务器重启也只会找AOF文件，那为什么不只使用AOF呢： 因为RDB更适合用于备份数据库（AOF在不断变化不好备份） AOF可能存在潜在bug，可以使用RDB作为备份 修复 如果appendonly.aof出现格式错误，则redis无法正常启动，此时可以通过 redis-check-aof --fix aof文件，进行修复。 如果dump.rdb出现格式错误，此时可以通过redis-check-rdb修复rdb文件 建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只需要15分钟备份一次即可 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件即可，代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎不可避免。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小，可以设置为5G以上，默认超过原大小100%大小时重写可以改到适当的数值 如果不Enable AOF，仅靠Master-Slave Replication 实现高可用性也可以。能够省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的哪个。 ","link":"https://qyylovexqx.github.io/post/redis-du-shu-bi-ji-lovegreater/"},{"title":"Redis读书笔记<2、Redis简介+Redis五大数据类型>","content":"Redis ： REmote DIctionary Server（远程字典服务器） 简介：高性能key/value分布式内存数据库，基于内存运行。支持持久化的NoSQL数据库 特点 支持数据的持久化，可以将内存中的数据保存在磁盘上，重启时可以再次加载使用 不仅支持简单的key-value类型的数据，同时还提供list,set,zset,hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份 功能 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务 取最新N个数据的操作：如可以将最新的10条评论的ID放在Redis的List集合里面 模拟类似于HttpSession这种需要设定过期时间的功能 发布、订阅消息系统 定时器、计数器 默认端口6379 Redis五大数据类型 Redis键（key） 常用 案例： keys * 查询某个数据库的所有key Exists key的名字 ，判断数据库中是否存在该key。(结果1，存在；结果0，不存在) move key dbNumber ,如 move k1 3，将当前库中的k1移动到数据库3中 Expire key 秒钟:为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永远不过期，-2 表示已过期 type key 查看key的类型 del key 删除key对应的键值对 Redis值（value） Redis字符串(String)-- 单键单值 set/get/del/append/strlen 追加：append key 追加内容 获取字符串长度：strlen key Incr/decr/incrby/decrby。（一定是数字才能加减） 加一减一：Incr/decr key 加减某个值：incrby/decrby key 加减值 getrange/setrange 获取、设置某个区间范围内的值 (0，-1)表示整个区间 setex(set with expire)键秒值、setnx(set if not exit) setex 键 存活时间 值 防覆盖：setnx 键 值 mset/mget/msetnx 批量插入: mset 键1 值1 键2 值2 键3 值3 批量获取：mget 键1 键2 键3 批量防覆盖插入：msetnx 键1 值1 键2 值2 键3 值3 getset(先get再set) Redis列表(List) 单键多值 总结： 本质是字符串链表，left/right都可以插入添加 如果键不存在，则创建新的链表 如果键已存在，新增内容 如果值完全移除，对应的键也就消失了 链表的操作无论是头和尾效率都极高，但如果是对中间元素进行操作，则效率比较低 API lpush/rpush/lrange Lpush 从左边依次插入（类似于头插法）：Lpush 列表 值1 值2 值3 ... Rpush 从右边依次插入 （类似于尾插法）：Rpush 列表 值1 值2 值3 ... Lrange 读取范围内的数据：Lrange 列表 起始下标 结束下标 Lpop、Rpop：从左边或者从右边出栈。Lpop/Rpop 列表 Lindex:按照索引下标获得元素。Lindex 列表 下标 LLEN：获取列表长度 Lrem key 删除N个value值 Ltrim key 开始index 结束index。截取指定范围的值后再赋值给Key，本质就是subList RpopLpush 源列表 目的列表。将原列表中的最后一个元素插入到目的列表的开头 Lset key index value。设置列表key中index上的值为value Linsert key before/after 值1 值2 Redis集合（Set）单键多值 API Sadd/smembers/sismember Sadd 往集合中添加元素(自动去重)：sadd 集合名 元素1 元素2 元素3 Smembers 查看集合中的所有元素：Smembers 集合名 sismember scard 获取集合里面的元素个数：scard 集合名 Srem key value 删除集合中的元素：Srem 集合名 元素 Srandmember 集合名 某个值x：从集合中每次随机挑选出x个元素 Spop key ：每次从集合中随机选一个元素出栈 Smove key1 key2 key1的某个元素：将key1集合中的某个元素放入key2集合中 数学集合类 差集sdiff: sdiff 集合1 集合2 。 找出在集合1里，但不在集合2里的元素 交集sinter:sdiff 集合1 集合2。 找出既在集合1里，也在集合2里的元素 并集sunion: sunion 集合1 集合2。 Redis哈希（Hash）KV模式不变，但V是一个键值对 Hset/hget/hmset/hmget/hgetall/hdel Hset 表 键 值：向表中插入一个键值对，如hset user name qyy Hget 表 键：从表中获取键的值，如hget user name Hmset 表 键1 值1 键2 值2 键3 值3：向表中插入多个键值对 hmset user age 24 sex 1 hgetall 表:获取表中所有键值对 hdel 表 键：删除表中某个键值对 hlen 表：查看表中键值对数目 hexists 表 表中某个key：判断表中是否存在某个键 Hkeys/hvals hkeys 表：获取某个表中的所有键 Hvals 表：获取某个表中的所有值 hincrby/hincrbyfloat hincrby 表 键 增加数：将表中某个键的值+增加数。如：hincrby user age 2 hincrbyfloat 表 键 增加数：将表中某个键的值+增加数。如hincrbyfloat user score 0.6 Hsetnx 表 键 值：当表中没有该键值时，插入该键值 Redis有序集合Zset（sorted set） 在set基础上，加一个score值。sadd k1 v1 v2 v3 ---&gt;zadd k1 score1 v1 score2 v2 score3 v3 API Zadd/zrange Zadd:例如zadd mySortedSet 10 v1 11 v2 13 v3 Zrange 集合 起始下标 结束下标：获取集合中起始下标到结束下标的所有元素 Zrange 集合 起始下标 结束下标 withscores ：获取集合中起始下标到结束下标的所有元素，并附带score Zrangebyscore 集合 开始score 结束score withscores：附带scores信息，如Zrangebyscore 集合 开始score 结束score withscores （ ： 不包含，如Zrangebyscore 集合 (开始score (结束score 。 不包含开始score和结束score Limit 起始地址个数 ：作用是返回限制。Zrangebyscore 集合 开始score 结束score limit 2 3。从一开始的结果集中的第二个元素开始，找出三个元素返回 Zrem 集合 元素：删除元素 Zcard/zcount/zrank/zscore Zcard 集合：获取集合中的总元素数目 zcount 集合 起始score 结束score：获取score区间的元素数目 Zrank 集合 元素：获取集合中元素的下标 Zscore 集合 元素：获取集合中元素的score值 zrevrank 集合 values值，作用是逆序获得下标值 [注] 官方命令文档：https://www.redis.net.cn/order/ ","link":"https://qyylovexqx.github.io/post/redis-du-shu-bi-ji-less2greater/"},{"title":"Redis学习笔记<1、基础知识>","content":"NoSQL数据库的四大分类： KV键值 案例：Redis 应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等 数据模型：key/value键值对，通常用hash table来实现 优点：查找速度快 缺点：数据无结构化，通常只被当做字符串或者二进制数据 文档型数据库(Bson格式比较多) 案例：MongoDB(是一个基于分布式文件存储的数据库，是一个介于关系数据库和非关系数据库之间的产品) 应用场景：Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） 数据模型：Key-Value对应的键值对，Value为结构化数据 优点：数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 缺点：查询性能不高，而且缺乏统一的查询语法 列存储数据库 案例：Cassandra、HBase。 应用场景：分布式文件系统 数据模型：以列簇式存储，将同一列数据存储在一起 优点：查找速度快，可扩展性强，更容易进行分布式扩展 缺点：功能相对局限 图关系数据库 案例：Neo4J，InfoGrid 应用场景：社交网络，推荐系统等。专注于构建关系图谱 数据模型：图结构 优点：利用图结构相关算法。比如最短路径寻址，N度关系查找等 缺点：很多时候需要对整个图做计算才能得出需要的信息。不易做分布式 分布式数据库中CAP原理CAP+BASE 传统的ACID Atomic Consistency Isolation Durability CAP C：Consistency（强一致性） A：Availability（可用性） P：Partition tolerance（分区容错性） CAP的3进2 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求，最多只能实现上面的两点，而由于当前网络硬件肯定会出现延迟丢包等问题，所以分区容错性必须要实现。 因此CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类： CA 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。如：RDBMS CP 满足一致性，分区容错性的系统，通常性能不是特别高。如：Redis、Mongodb AP 满足可用性，分区容错性的系统，通常可能对一致性要求低一些。如：CouchDB BASE：为了解决关系数据库强一致性引起的可用性降低而提出的解决方案：通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上的改观。 Basically Available 基本可用 Soft state 软状态 Eventually consistent 最终一致 ","link":"https://qyylovexqx.github.io/post/redis-xue-xi-bi-ji-less1greater/"}]}